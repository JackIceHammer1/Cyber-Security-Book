Securing a Linux system starts with understanding and implementing fundamental security practices. These basics form the foundation upon which more advanced security measures are built. This chapter covers essential aspects of Linux security, including file permissions, user and group management, firewall configuration, SELinux and AppArmor, and Secure Shell (SSH) and remote access.

1. File Permissions and Ownership

Linux uses a robust permission system to control access to files and directories. Understanding and managing these permissions is critical for system security.

File Permissions: Each file and directory in Linux has a set of permissions that define who can read, write, and execute the file.

Read (r): Allows viewing the contents of a file or listing the contents of a directory.
Write (w): Allows modifying the contents of a file or creating and deleting files within a directory.
Execute (x): Allows running a file as a program or entering a directory.
Permissions are represented by a combination of three sets of letters (r, w, x), each set corresponding to the owner, the group, and others. For example, rwxr-xr-- indicates that the owner can read, write, and execute the file; the group can read and execute it; and others can only read it.

Ownership: Each file and directory has an owner and a group associated with it.

Owner: The user who owns the file or directory.
Group: A group of users who have specific permissions on the file or directory.
Use the chown command to change the owner and group of a file, and the chmod command to change its permissions. For example, chmod 755 file.txt sets the file's permissions to rwxr-xr-x.

Special Permissions: Linux also supports special permissions like SUID, SGID, and Sticky Bit.

SUID (Set User ID): Allows a user to execute a file with the permissions of the file owner. Set using chmod u+s filename.
SGID (Set Group ID): Allows a file to be executed with the permissions of the file's group or sets the group of files created within a directory. Set using chmod g+s filename.
Sticky Bit: Applied to directories to ensure that only the owner of a file can delete or rename it. Set using chmod +t directory.
2. User and Group Management

Properly managing users and groups is essential for maintaining security and controlling access to system resources.

User Accounts: Each user account has a unique user ID (UID) and is associated with a home directory and a default shell. Use the useradd command to create a new user, and usermod to modify existing users.

Password Management: Ensure strong password policies by using the passwd command to set and change passwords. Use tools like chage to enforce password expiration and complexity requirements.
Group Management: Groups allow administrators to assign permissions to multiple users collectively. Each group has a unique group ID (GID). Use the groupadd command to create a new group, and groupmod to modify existing groups.

Assigning Users to Groups: Use the usermod -aG groupname username command to add a user to a group. The /etc/group file contains a list of groups and their members.
Access Control Lists (ACLs): ACLs provide more fine-grained permissions beyond the standard file permissions. Use the setfacl and getfacl commands to set and view ACLs. For example, setfacl -m u:username:rwx filename grants the specified user full permissions on the file.

3. Firewall Configuration (iptables, firewalld)

Firewalls are critical for controlling network traffic and protecting a system from unauthorized access.

iptables: iptables is a command-line tool for configuring the Linux kernel's netfilter framework. It defines rules that filter and manipulate network packets.

Basic Commands: Use iptables -A to add a rule, iptables -D to delete a rule, and iptables -L to list rules. For example, iptables -A INPUT -p tcp --dport 22 -j ACCEPT allows SSH traffic on port 22.
Saving Rules: Save iptables rules to ensure they persist across reboots using iptables-save > /etc/iptables/rules.v4 and restore them with iptables-restore < /etc/iptables/rules.v4.
firewalld: firewalld provides a dynamic interface for managing firewall rules, supporting zones and services.

Zones: Zones define a set of rules for network interfaces. Use firewall-cmd --get-zones to list available zones and firewall-cmd --zone=zone --add-service=service to add a service to a zone.
Services: Predefined services simplify rule creation. Use firewall-cmd --get-services to list services and firewall-cmd --add-service=service to add a service.
Permanent Rules: To make rules permanent, add the --permanent flag. For example, firewall-cmd --permanent --zone=public --add-service=http allows HTTP traffic in the public zone.
4. SELinux and AppArmor

Security-Enhanced Linux (SELinux) and AppArmor are Linux security modules that provide mandatory access control (MAC) policies to enhance system security.

SELinux: SELinux enforces policies that define how processes interact with files, devices, and other processes.

Modes: SELinux operates in three modes: enforcing, permissive, and disabled. Use setenforce 1 to enable enforcing mode and setenforce 0 for permissive mode.
Context Labels: Files and processes have context labels that determine their permissions. Use ls -Z to view labels and chcon to change them.
Policy Management: Use semanage to manage policies and audit2allow to create custom rules from audit logs.
AppArmor: AppArmor confines programs to a limited set of resources using profile-based policies.

Profiles: Profiles define the access permissions for applications. Use aa-status to check the status of AppArmor and aa-enforce to enforce a profile.
Profile Creation: Use aa-genprof to generate a new profile and aa-logprof to update profiles based on log entries.
5. Secure Shell (SSH) and Remote Access

SSH provides secure remote access to Linux systems, enabling encrypted communication and various authentication methods.

SSH Configuration: The SSH server is configured via the /etc/ssh/sshd_config file. Common configurations include changing the default port (Port 22), disabling root login (PermitRootLogin no), and enabling key-based authentication (PubkeyAuthentication yes).

Key-Based Authentication: Generate a key pair using ssh-keygen and add the public key to the ~/.ssh/authorized_keys file on the remote server. This method enhances security by eliminating password-based logins.

SSH Tunneling: SSH tunneling allows secure forwarding of network traffic. Use ssh -L local_port:remote_host:remote_port user@remote_host to create a local tunnel.

Summary

On this first page of Chapter 8, we have covered fundamental Linux security practices, including file permissions and ownership, user and group management, firewall configuration, SELinux and AppArmor, and SSH and remote access. These basics are essential for establishing a secure Linux environment. The next pages will delve deeper into each of these topics, providing detailed guidance and examples.